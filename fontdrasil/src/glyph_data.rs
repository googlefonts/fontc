//! Access to data extracted from glyphs.app
//!
//! This data is needed when parsing glyphs files, but it is also useful in other places,
//! particularly for classifying glyphs for feature generation.
//!
//! The important thing about this data is that it is based on the conventional glyph names used by
//! designers, and includes information about glyphs that are not encoded in unicode (such as various
//! ligatures and combined base/mark pairs)

// this file is generated by the script at ../glyphdata/rebuild.py
include!("../glyphdata/generated_glyph_data.rs");

/// The primary category for a given glyph
///
/// These categories are not the same as the unicode character categories.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(u8)]
pub enum Category {
    Mark,
    Space,
    Separator,
    Letter,
    Number,
    Symbol,
    Punctuation,
    Other,
}

/// The subcategory of a given glyph
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(u8)]
pub enum Subcategory {
    Spacing,
    Radical,
    Math,
    Superscript,
    Geometry,
    Dash,
    DecimalDigit,
    Currency,
    Fraction,
    Halfform,
    Small,
    Number,
    Quote,
    Space,
    Letter,
    Jamo,
    Format,
    Parenthesis,
    Matra,
    Arrow,
    Nonspacing,
    Compatibility,
    Syllable,
    Ligature,
    Modifier,
    SpacingCombining,
    Emoji,
    Enclosing,
    None,
}

/// The Category & Subcategory of a glyph, per the glyphs.app GlyphData
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GlyphInfo {
    pub category: Category,
    pub sub_category: Subcategory,
}

impl GlyphInfo {
    const NONSPACING_MARK: Self = GlyphInfo::new(Category::Mark, Subcategory::Nonspacing);

    /// Lookup the glyph categories for this glyph, by name
    pub fn for_glyph(name: &str) -> Option<Self> {
        CATEGORIES.get(name).copied()
    }

    const fn new(category: Category, sub_category: Subcategory) -> Self {
        GlyphInfo {
            category,
            sub_category,
        }
    }
}

/// Returns `true` if this glyph name matches a known nonspacing mark
pub fn is_nonspacing_mark_name(name: &str) -> bool {
    // fast exit: length cannot match a mark
    if name.len() > 35 || matches!(name.len(), 1 | 2) {
        return false;
    }

    CATEGORIES
        .get(name)
        .map(|info| *info == GlyphInfo::NONSPACING_MARK)
        .unwrap_or(false)
}
