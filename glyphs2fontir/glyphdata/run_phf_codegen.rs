//! part of our codegen process
//!
//! The input is a file generated from python using glyphsLib (from
//! resources/scripts/rebuild_glyph_data.py) output is printed to stdout
//!
//! see glyphdata/README.md

use std::env;

fn main() {
    let Some(in_path) = env::args().nth(1) else {
        print_help_and_die();
    };

    let input = std::fs::read_to_string(in_path).expect("couldn't read input");
    let input = parse_input(&input);

    println!(
        "// THIS FILE IS AUTOGENERATED\n\
        // see fontdrasil/glyphdata/README.md for more information"
    );

    let categories = make_map(&input.categories);
    let codepoints = make_map(&input.codepoints);
    println!(
        "static CATEGORIES: phf::Map<&'static str, GlyphInfo> = {};",
        categories.build()
    );

    println!(
        "static CODEPOINT_TO_NAME: phf::Map<u32, &'static str> = {};",
        codepoints.build()
    )
}

struct Input<'a> {
    categories: Vec<(&'a str, &'a str)>,
    codepoints: Vec<(u32, String)>,
}

fn parse_input(raw_input: &str) -> Input {
    let mut categories = Vec::new();
    let mut codepoints = Vec::new();

    for line in raw_input.lines() {
        let Some((name, rest)) = line.split_once(',') else {
            panic!("bad line: '{line}'");
        };
        let rest = rest.trim();
        if rest.starts_with("0x") {
            let (codepoint, rest) = rest.split_once(',').unwrap();
            let codepoint = codepoint.trim_start_matches("0x");
            let codepoint = match u32::from_str_radix(codepoint, 16) {
                Ok(digit) => digit,
                Err(_) => panic!("oh no '{codepoint}'"),
            };
            codepoints.push((codepoint, format!("\"{name}\"")));
            categories.push((name, rest));
        } else {
            categories.push((name, rest));
        }
    }

    Input {
        categories,
        codepoints,
    }
}

fn make_map<K, S>(items: &[(K, S)]) -> phf_codegen::Map<K>
where
    K: std::hash::Hash + phf::PhfHash + Eq + phf_shared::FmtConst + Copy,
    S: AsRef<str>,
{
    let mut map = phf_codegen::Map::new();
    for (key, value) in items {
        map.entry(*key, value.as_ref().trim());
    }
    map
}

//fn make_codegen(raw_input: &str) -> phf_codegen::Map<&str> {
//let mut map = phf_codegen::Map::new();
//for line in raw_input.lines() {
//let Some((name, info)) = line.split_once(',') else {
//panic!("bad line: '{line}'");
//};
//map.entry(name.trim(), info.trim());
//}
//map
//}

fn print_help_and_die() -> ! {
    eprintln!(
        "You should not execute this binary directly. It is run as part of glyph_data/rebuild.py"
    );
    std::process::exit(1)
}
