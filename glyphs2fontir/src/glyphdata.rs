//! Access to data extracted from glyphs.app
//!
//! This data is needed when parsing glyphs files, but it is also useful in other places,
//! particularly for classifying glyphs for feature generation.
//!
//! The important thing about this data is that it is based on the conventional glyph names used by
//! designers, and includes information about glyphs that are not encoded in unicode (such as various
//! ligatures and combined base/mark pairs)
//!
//! Run resources/scripts/non_spacing_marks.py to update

use std::collections::HashSet;

// this file is generated by the script at ../glyphdata/rebuild.py
include!("../glyphdata/generated_glyph_data.rs");

/// The primary category for a given glyph
///
/// These categories are not the same as the unicode character categories.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(u8)]
pub enum Category {
    Mark,
    Space,
    Separator,
    Letter,
    Number,
    Symbol,
    Punctuation,
    Other,
}

/// The subcategory of a given glyph
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(u8)]
pub enum Subcategory {
    Spacing,
    Radical,
    Math,
    Superscript,
    Geometry,
    Dash,
    DecimalDigit,
    Currency,
    Fraction,
    Halfform,
    Small,
    Number,
    Quote,
    Space,
    Letter,
    Jamo,
    Format,
    Parenthesis,
    Matra,
    Arrow,
    Nonspacing,
    Compatibility,
    Syllable,
    Ligature,
    Modifier,
    SpacingCombining,
    Emoji,
    Enclosing,
    None,
}

/// The Category & Subcategory of a glyph, per the glyphs.app GlyphData
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GlyphInfo {
    pub category: Category,
    pub sub_category: Subcategory,
}

impl GlyphInfo {
    const NONSPACING_MARK: Self = GlyphInfo::new(Category::Mark, Subcategory::Nonspacing);

    /// Lookup the glyph categories for a glyph by name
    pub fn for_glyph(name: &str) -> Option<Self> {
        CATEGORIES.get(name).copied()
    }

    /// Lookup the glyph categories for a glyph by codepoint
    pub fn for_codepoint(codepoint: u32) -> Option<Self> {
        CODEPOINT_TO_NAME
            .get(&codepoint)
            .copied()
            .and_then(Self::for_glyph)
    }

    const fn new(category: Category, sub_category: Subcategory) -> Self {
        GlyphInfo {
            category,
            sub_category,
        }
    }
}

/// Returns `true` if this glyph name matches a known nonspacing mark
pub(crate) fn is_nonspacing_mark_name(name: &str) -> bool {
    // fast exit: length cannot match a mark
    if name.len() > 35 || matches!(name.len(), 1 | 2) {
        return false;
    }

    GlyphInfo::for_glyph(name)
        .map(|info| info == GlyphInfo::NONSPACING_MARK)
        .unwrap_or(false)
}

fn any_nonspacing_mark_codepoint(codepoints: &HashSet<u32>) -> bool {
    // Failing name try by codepoint
    codepoints
        .iter()
        .filter_map(|cp| GlyphInfo::for_codepoint(*cp))
        .any(|info| info == GlyphInfo::NONSPACING_MARK)
}

pub(crate) fn is_nonspacing_mark(codepoints: &HashSet<u32>, name: &str) -> bool {
    // Try first by name, then codepoint
    is_nonspacing_mark_name(name) || any_nonspacing_mark_codepoint(codepoints)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn potential_mark_accutcomb() {
        assert!(is_nonspacing_mark_name("acutecomb"));
    }

    #[test]
    fn potential_mark_accut_whatever() {
        assert!(!is_nonspacing_mark_name("acutWHATEVER"));
    }

    #[test]
    fn funny_name_correct_codepoint() {
        let codepoints = HashSet::from([0x301]);
        assert!(is_nonspacing_mark(&codepoints, "acutWHATEVER"))
    }
}
